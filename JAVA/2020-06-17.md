## 2020-06-17

**static 메서드 안에서는 non-static 메서드는 호출이 안된다. -> 규칙**

**따라서 객체를 만들어서 호출한다.**

```java
public class ReferenceReturnEx02 {
    //반환값이 있는 메서드를 -> 반환값이 없는 메서드로
    int add(int a, int b){
        return a + b;
    }
    
    void add(int a, int b, int[] result){
        result[0] = a + b;
    }
    
    public static void main(String[] args){
        
        ReferenceReturnEx02 r02 = new ReferenceReturnEx02();
        int result = r02.add(2, 3);
        System.out.println(result);
        
        int[] result2 = new int[1];
        r02.add(2, 3, result2);
        System.out.println("result2[0] : " + result2[0]);
    }
}
```

```
5
result2[0] : 5
```



### 재귀호출(Recursive Call)

메서드의 내부에서 메서드 자신을 호출 (무한 루프를 벗어날 조건문 필요.)

재귀호출은 반복문으로 바꿀 수 있다.(성능은 반복문보다 떨어짐.)

이해하기 쉽고 간결

예 : 팩토리얼, 제곱, 트리운행, 폴더 목록 표시

```java
// Factorial
public class FactorialEx01Main{
    static int factorial(int n){
        int result = 0;

        if(n == 1){
            result = 1;
        } else {
            result = n * factoral(n - 1);
            System.out.println(result + ", " + n);
        }
		return result;
	}
    
    public static void main(String[] args){
        
        int result = factorial(5);
        System.out.println("result : " + result);
        
    }
    
}
```

```java
// 반복문으로
static int factorial(int a){
    int result = 1;
    while(n != 0){
        result *= n - 1;
    }
    return result;
}
```

#### 

### 클래스 메서드(static 메서드)

- 인스턴스 변수나 인스턴스 메서드와 관련 없는 작업 시 사용.
- 메서드 내에서 인스턴스 변수 사용 불가.
- 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static 메서드 고려.
- 객체 생성 없이 사용 가능, 클래스이름.메서드 로 호출.

#### 인스턴스 메서드

|                            MyMath                            |
| :----------------------------------------------------------: |
|                     long a;<br />long b;                     |
| add() : long<br />subtract() : long<br />multiply() : long<br />divide() : double<br /><br />add(a:long, b:long) : long<br />subtract(a:long, b:long) : long<br />multiply(a:long, b:long) : long<br />divide(a:double, b:doube) : double |

​	![](https://github.com/osk14741/ehrStudy/blob/master/JAVA/img/static01.jpeg)

```java
// 1
public class MyCalculator {
    public static appName = "MyCalculator";
    
    public static int add(int x, int y){
        return x + y;
    }
    
    public int min(int x, int y){
        return x - y;
    }    
}

MyCalculator.add(1, 2); //static 메소드이므로 객체 생성 없이 사용 가능
MyCalculator.min(1, 2); //static 메소드가 아니므로 객체 생성 없이 사용 불가능

MyCalculator cal = new MyCalculator();
cal.add(1, 2); //사용 가능한데 static 써놓고 굳이 왜?
cal.min(1, 2); //사용 가능
```

```java
// 2
public class Test {
	private String name1 = "a";
	private static String name2 = "b";
	
	public static void printMax(int x, int y) {
		System.out.println(Math.max(x, y));
	}
	
	public static void printName(){
		System.out.println(name1); //불가능한 호출.
		SYstem.out.println(name2);
	}
}
```

두 수의 최대값을 구하는 경우에 Math 클래스를 사용하는데, static 메서드인 max함수를 초기화 없이 사용한다. 하지만 static 메소드에서는 static이 선언되지 않은 변수에 접근이 불가능한데, 메모리 할당과 연관지어 생각해보면 당연합니다. 우리가 Test.printName() 을 사용하려고 하는데, name1은 new 연산을 통해 객체가 생성된 후 메모리가 할당됩니다. 하지만 static 메서드는 객체의 생성 없이 접근하는 함수이므로, 할당되지 않은 메모리 영역에 접근을 하므로 문제가 발생하게 됩니다. 그러므로 static 변수에 접근하기 위한 메서드는 반드시 static 메서드여야 합니다.