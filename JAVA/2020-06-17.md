## 2020-06-17

**static 메서드 안에서는 non-static 메서드는 호출이 안된다. -> 규칙**

**따라서 객체를 만들어서 호출한다.**

```java
public class ReferenceReturnEx02 {
    //반환값이 있는 메서드를 -> 반환값이 없는 메서드로
    int add(int a, int b){
        return a + b;
    }
    
    void add(int a, int b, int[] result){
        result[0] = a + b;
    }
    
    public static void main(String[] args){
        
        ReferenceReturnEx02 r02 = new ReferenceReturnEx02();
        int result = r02.add(2, 3);
        System.out.println(result);
        
        int[] result2 = new int[1];
        r02.add(2, 3, result2);
        System.out.println("result2[0] : " + result2[0]);
    }
}
```

```
5
result2[0] : 5
```



### 재귀호출(Recursive Call)

메서드의 내부에서 메서드 자신을 호출 (무한 루프를 벗어날 조건문 필요.)

재귀호출은 반복문으로 바꿀 수 있다.(성능은 반복문보다 떨어짐.)

이해하기 쉽고 간결

예 : 팩토리얼, 제곱, 트리운행, 폴더 목록 표시

```java
// Factorial
public class FactorialEx01Main{
    static int factorial(int n){
        int result = 0;

        if(n == 1){
            result = 1;
        } else {
            result = n * factoral(n - 1);
            System.out.println(result + ", " + n);
        }
		return result;
	}
    
    public static void main(String[] args){
        
        int result = factorial(5);
        System.out.println("result : " + result);
        
    }
    
}
```

```java
// 반복문으로
static int factorial(int a){
    int result = 1;
    while(n != 0){
        result *= n - 1;
    }
    return result;
}
```

#### 

### 클래스 메서드(static 메서드)

- 인스턴스 변수나 인스턴스 메서드와 관련 없는 작업 시 사용.
- 메서드 내에서 인스턴스 변수 사용 불가.
- 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static 메서드 고려.
- 객체 생성 없이 사용 가능, 클래스이름.메서드 로 호출.

#### 인스턴스 메서드

|                            MyMath                            |
| :----------------------------------------------------------: |
|                     long a;<br />long b;                     |
| add() : long<br />subtract() : long<br />multiply() : long<br />divide() : double<br /><br />add(a:long, b:long) : long<br />subtract(a:long, b:long) : long<br />multiply(a:long, b:long) : long<br />divide(a:double, b:doube) : double |

